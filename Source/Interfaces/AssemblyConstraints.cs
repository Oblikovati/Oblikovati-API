namespace Oblikovati.API;

/// <summary>
/// Provides access to the collection in the top level of the assembly.
/// </summary>
public interface AssemblyConstraints : IEnumerable
{
    /// <summary>
    /// Returns the top-level parent application object.  When used the context of Inventor, an Application object is returned.  When used in the context of Apprentice, an ApprenticeServer object is returned.
    /// </summary>
    object Application { get; }
    /// <summary>
    /// Property that returns the parent of the object.
    /// </summary>
    AssemblyComponentDefinition Parent { get; }
    /// <summary>
    /// Returns an ObjectTypeEnum indicating this object's type.
    /// </summary>
    ObjectTypeEnum Type { get; }
    /// <summary>
    /// Returns the specified AssemblyConstraint object from the collection. This is the default property of the AssemblyConstraints collection object.
    /// </summary>
    AssemblyConstraint Item { get; }
    /// <summary>
    /// Property that returns the number of items in this collection.
    /// </summary>
    int Count { get; }
    /// <summary>
    /// Missing documentation! Help us documenting it!
    /// </summary>
    /// <param name="EntityOne">EntityOne</param>
    /// <param name="DirectionOneReversed">DirectionOneReversed</param>
    /// <param name="EntityTwo">EntityTwo</param>
    /// <param name="DirectionTwoReversed">DirectionTwoReversed</param>
    /// <param name="Angle">Angle</param>
    /// <param name="BiasPointOne">BiasPointOne</param>
    /// <param name="BiasPointTwo">BiasPointTwo</param>
    [PreserveSig]
    AngleConstraint _AddAngleConstraint([In] [MarshalAs(UnmanagedType.IDispatch)] object EntityOne, [In] bool DirectionOneReversed, [In] [MarshalAs(UnmanagedType.IDispatch)] object EntityTwo, [In] bool DirectionTwoReversed, [In] [MarshalAs(UnmanagedType.Struct)] object Angle, [In] [MarshalAs(UnmanagedType.Struct)] object? BiasPointOne = default, [In] [MarshalAs(UnmanagedType.Struct)] object? BiasPointTwo = default);
    /// <summary>
    /// Missing documentation! Help us documenting it!
    /// </summary>
    /// <param name="EntityOne">EntityOne</param>
    /// <param name="DirectionOneReversed">DirectionOneReversed</param>
    /// <param name="EntityTwo">EntityTwo</param>
    /// <param name="DirectionTwoReversed">DirectionTwoReversed</param>
    /// <param name="Angle">Angle</param>
    /// <param name="BiasPointOne">BiasPointOne</param>
    /// <param name="BiasPointTwo">BiasPointTwo</param>
    /// <param name="Directed">Directed</param>
    [PreserveSig]
    AngleConstraint _AddAngleConstraint2([In] [MarshalAs(UnmanagedType.IDispatch)] object EntityOne, [In] bool DirectionOneReversed, [In] [MarshalAs(UnmanagedType.IDispatch)] object EntityTwo, [In] bool DirectionTwoReversed, [In] [MarshalAs(UnmanagedType.Struct)] object Angle, [In] [MarshalAs(UnmanagedType.Struct)] object? BiasPointOne = default, [In] [MarshalAs(UnmanagedType.Struct)] object? BiasPointTwo = default, [In] bool? Directed = true);
    /// <summary>
    /// Method that creates a new angle assembly constraint.
    /// </summary>
    /// <param name="EntityOne">Input object that defines the first object. This object can be a planar face, work plane, linear edge, work axis, or a face that defines an axis.</param>
    /// <param name="EntityTwo">Input object that defines the second object. This object can be a planar face, work plane, linear edge, work axis, or a face that defines an axis.</param>
    /// <param name="Angle">Input Variant that defines the angle between the two input entities. This can be either a numeric value or a string. A parameter for this value is created and the supplied string or value is assigned to the parameter. If a value is input, the units are radians. If a string is input, the units can be specified as part of the string or will default to the current angle units of the document.</param>
    /// <param name="SolutionType">Optional input AngleConstraintSolutionTypeEnum that specifies the solution type. If specified to be kDirectionSolution, the solution always applies the right hand rule. If specified to be kUndirectionSolution, the solution allows either orientation, thus resolving situations where component orientation flips during a constraint drive or drag. If specified to be kReferenceVectorSolution, the ReferenceVectorEntity argument must be provided with a third entity for the solution. The default value is kDirectionSolution.</param>
    /// <param name="ReferenceVectorEntity">Optional input object that provides a third entity to solve the angle constraint. This argument is ignored if the SolutionType argument is not kReferenceVectorSolution. This object can be a planar face, work plane, linear edge, work axis, or a face that defines an axis.</param>
    /// <param name="BiasPointOne">Optional input object that is used help in determining the initial position of the occurrence. The occurrences are repositioned in an attempt to make the two bias points coincident. This provides some general control over the position of the occurrence when it isn't being controlled by another constraint. An example of when the bias points are useful is the case when the first constraint on a part is a mate constraint. In the case where the mate is between two planes, the parts can be positioned anywhere along the infinite plane that defines their mating contact. Using the bias points you can define the position of the two occurrences, relative to each other. If a bias point is not given, one is calculated that is at the center of the parameter range of the input entity.</param>
    /// <param name="BiasPointTwo">Optional input object that is used to help in determining the initial position of the occurrence. The occurrences are repositioned in an attempt to make the two bias points coincident. This provides some general control over the position of the occurrence when it isn't being controlled by another constraint. An example of when the bias points are useful is the case when the first constraint on a part is a mate constraint. In the case where the mate is between two planes, the parts can be positioned anywhere along the infinite plane that defines their mating contact. Using the bias points you can define the position of the two occurrences, relative to each other. If a bias point is not given, one is calculated that is at the center of the parameter range of the input entity.</param>
    /// <returns></returns>
    [PreserveSig]
    AngleConstraint AddAngleConstraint([In] [MarshalAs(UnmanagedType.IDispatch)] object EntityOne, [In] [MarshalAs(UnmanagedType.IDispatch)] object EntityTwo, [In] [MarshalAs(UnmanagedType.Struct)] object Angle, [In] AngleConstraintSolutionTypeEnum? SolutionType = AngleConstraintSolutionTypeEnum.kDirectedSolution, [In] [MarshalAs(UnmanagedType.Struct)] object? ReferenceVectorEntity = default, [In] [MarshalAs(UnmanagedType.Struct)] object? BiasPointOne = default, [In] [MarshalAs(UnmanagedType.Struct)] object? BiasPointTwo = default);
    /// <summary>
    /// Method that creates a new insert assembly constraint.
    /// </summary>
    /// <param name="EntityOne">Object that defines the first object. This object is a circular edge.</param>
    /// <param name="EntityTwo">Object that defines the second object. This object is a circular edge.</param>
    /// <param name="AxesOpposed">Input Boolean that specifies whether the direction of the axes of the input entities are in the same direction or opposed. A value of True indicates they are opposed.</param>
    /// <param name="Distance">Input Variant that defines the offset between the two input entities. This can be either a numeric value or a string. A parameter for this value is created and the supplied string or value is assigned to the parameter. If a value is input, the units are centimeters. If a string is input the units can be specified as part of the string or will default to the current length units of the document.</param>
    /// <param name="BiasPointOne">Optional input object that is used help in determining the initial position of the occurrence. The occurrences are repositioned in an attempt to make the two bias points coincident. This provides some general control over the position of the occurrence when it isn't being controlled by another constraint. An example of when the bias points are useful is the case when the first constraint on a part is a mate constraint. In the case where the mate is between two planes, the parts can be positioned anywhere along the infinite plane that defines their mating contact. Using the bias points you can define the position of the two occurrences, relative to each other. If a bias point is not given, one is calculated that is at the center of the parameter range of the input entity.</param>
    /// <param name="BiasPointTwo">Optional input object that is used help in determining the initial position of the occurrence. The occurrences are repositioned in an attempt to make the two bias points coincident. This provides some general control over the position of the occurrence when it isn't being controlled by another constraint. An example of when the bias points are useful is the case when the first constraint on a part is a mate constraint. In the case where the mate is between two planes, the parts can be positioned anywhere along the infinite plane that defines their mating contact. Using the bias points you can define the position of the two occurrences, relative to each other. If a bias point is not given, one is calculated that is at the center of the parameter range of the input entity.</param>
    /// <returns></returns>
    [PreserveSig]
    InsertConstraint AddInsertConstraint([In] [MarshalAs(UnmanagedType.IDispatch)] object EntityOne, [In] [MarshalAs(UnmanagedType.IDispatch)] object EntityTwo, [In] bool AxesOpposed, [In] [MarshalAs(UnmanagedType.Struct)] object Distance, [In] [MarshalAs(UnmanagedType.Struct)] object? BiasPointOne = default, [In] [MarshalAs(UnmanagedType.Struct)] object? BiasPointTwo = default);
    /// <summary>
    /// Method that creates a new tangent assembly constraint.
    /// </summary>
    /// <param name="EntityOne">Input object that defines the first object.</param>
    /// <param name="EntityTwo">Input object that defines the second object. This object is a circular edge.</param>
    /// <param name="InsideTangency">Input Boolean that specifies the orientation of the surfaces at the tangent contact point of the surfaces.</param>
    /// <param name="Offset">Input Variant that defines the offset between the two input entities. This can be either a numeric value or a string. A parameter for this value is created and the supplied string or value is assigned to the parameter. If a value is input, the units are centimeters. If a string is input the units can be specified as part of the string or will default to the current length units of the document.</param>
    /// <param name="BiasPointOne">Optional input object that is used help in determining the initial position of the occurrence. The occurrences are repositioned in an attempt to make the two bias points coincident. This provides some general control over the position of the occurrence when it isn't being controlled by another constraint. An example of when the bias points are useful is the case when the first constraint on a part is a mate constraint. In the case where the mate is between two planes, the parts can be positioned anywhere along the infinite plane that defines their mating contact. Using the bias points you can define the position of the two occurrences, relative to each other. If a bias point is not given, one is calculated that is at the center of the parameter range of the input entity.</param>
    /// <param name="BiasPointTwo">Optional input object that is used help in determining the initial position of the occurrence. The occurrences are repositioned in an attempt to make the two bias points coincident. This provides some general control over the position of the occurrence when it isn't being controlled by another constraint. An example of when the bias points are useful is the case when the first constraint on a part is a mate constraint. In the case where the mate is between two planes, the parts can be positioned anywhere along the infinite plane that defines their mating contact. Using the bias points you can define the position of the two occurrences, relative to each other. If a bias point is not given, one is calculated that is at the center of the parameter range of the input entity.</param>
    /// <returns></returns>
    [PreserveSig]
    TangentConstraint AddTangentConstraint([In] [MarshalAs(UnmanagedType.IDispatch)] object EntityOne, [In] [MarshalAs(UnmanagedType.IDispatch)] object EntityTwo, [In] bool InsideTangency, [In] [MarshalAs(UnmanagedType.Struct)] object Offset, [In] [MarshalAs(UnmanagedType.Struct)] object? BiasPointOne = default, [In] [MarshalAs(UnmanagedType.Struct)] object? BiasPointTwo = default);
    /// <summary>
    /// Method that creates a new mate assembly constraint. The two input entities can be a combination of planar faces, linear edges, vertices, cylindrical faces, conical faces, spherical faces, revolved faces, work planes, work axes, and work points. When a cylindrical, conical, or revolved face is input, the axis of the surface is used for the constraint. When a sphere is input, the center point of the sphere is used for the constraint. To use the surface of a cylindrical, conical, or spherical face use the EntityOneInferredType or EntityTwoInferredType arguments.
    /// </summary>
    /// <param name="EntityOne">Input object that defines the first object.</param>
    /// <param name="EntityTwo">Input object that defines the second object.</param>
    /// <param name="Offset">Input Variant that defines the offset between the two input entities. This can be either a numeric value or a string. A parameter for this value is created and the supplied string or value is assigned to the parameter. If a value is input, the units are centimeters. If a string is input the units can be specified as part of the string or will default to the current length units of the document.</param>
    /// <param name="EntityOneInferredType">Optional input constant that specifies how the geometry of entity one is to be interpreted. Depending on the geometry of the entity one, different options are possible. If entity one is a cylinder this can be either kNoInference or kInferredLine. For kNoInference to be valid for a cylinder, entity two must also be a cylinder and they must be the same radius. If entity one is a sphere this can be either kNoInference or kInferredPoint. For kNoInference to be valid for a sphere, entity two must also be a sphere and they must be the same radius. If entity one is a cone this can be either kNoInference or kInferredLine. For kNoInference to be valid for a cone, entity two must also be a cone and they must have the same taper angle. If entity one is a torus this can be either kInferredLine or kInferredPoint. For a plane, only kNoInference is valid.</param>
    /// <param name="EntityTwoInferredType">Input enum that specifies how the geometry of entity two is to be interpreted. Depending on the geometry of the entity two, different options are possible. If entity two is a cylinder this can be either kNoInference or kInferredLine. For kNoInference to be valid for a cylinder, entity one must also be a cylinder and they must be the same radius. If entity two is a sphere this can be either kNoInference or kInferredPoint. For kNoInference to be valid for a sphere, entity one must also be a sphere and they must be the same radius. If entity two is a cone this can be either kNoInference or kInferredLine. For kNoInference to be valid for a cone, entity one must also be a cone and they must have the same taper angle. If entity two is a torus this can be either kInferredLine or kInferredPoint. For a plane, only kNoInference is valid.</param>
    /// <param name="BiasPointOne">Optional input object that is used help in determining the initial position of the occurrence. The occurrences are repositioned in an attempt to make the two bias points coincident. This provides some general control over the position of the occurrence when it isn't being controlled by another constraint. An example of when the bias points are useful is the case when the first constraint on a part is a mate constraint. In the case where the mate is between two planes, the parts can be positioned anywhere along the infinite plane that defines their mating contact. Using the bias points you can define the position of the two occurrences, relative to each other. If a bias point is not given, one is calculated that is at the center of the parameter range of the input entity.</param>
    /// <param name="BiasPointTwo">Optional input object that is used help in determining the initial position of the occurrence. The occurrences are repositioned in an attempt to make the two bias points coincident. This provides some general control over the position of the occurrence when it isn't being controlled by another constraint. An example of when the bias points are useful is the case when the first constraint on a part is a mate constraint. In the case where the mate is between two planes, the parts can be positioned anywhere along the infinite plane that defines their mating contact. Using the bias points you can define the position of the two occurrences, relative to each other. If a bias point is not given, one is calculated that is at the center of the parameter range of the input entity.</param>
    /// <returns></returns>
    [PreserveSig]
    MateConstraint AddMateConstraint([In] [MarshalAs(UnmanagedType.IDispatch)] object EntityOne, [In] [MarshalAs(UnmanagedType.IDispatch)] object EntityTwo, [In] [MarshalAs(UnmanagedType.Struct)] object Offset, [In] InferredTypeEnum? EntityOneInferredType = InferredTypeEnum.kNoInference, [In] InferredTypeEnum? EntityTwoInferredType = InferredTypeEnum.kNoInference, [In] [MarshalAs(UnmanagedType.Struct)] object? BiasPointOne = default, [In] [MarshalAs(UnmanagedType.Struct)] object? BiasPointTwo = default);
    /// <summary>
    /// Method that creates a new flush assembly constraint.
    /// </summary>
    /// <param name="EntityOne">Input object that defines the first object. The input object must be either a planar object or WorkPlane object.</param>
    /// <param name="EntityTwo">Input object that defines the second object. The input object must be either a planar object or WorkPlane object</param>
    /// <param name="Offset">Input Variant that defines the offset between the two input entities. This can be either a numeric value or a string. A parameter for this value is created and the supplied string or value is assigned to the parameter. If a value is input, the units are centimeters. If a string is input the units can be specified as part of the string or will default to the current length units of the document.</param>
    /// <param name="BiasPointOne">Optional input object that is used help in determining the initial position of the occurrence. The occurrences are repositioned in an attempt to make the two bias points coincident. This provides some general control over the position of the occurrence when it isn't being controlled by another constraint. An example of when the bias points are useful is the case when the first constraint on a part is a mate constraint. In the case where the mate is between two planes, the parts can be positioned anywhere along the infinite plane that defines their mating contact. Using the bias points you can define the position of the two occurrences, relative to each other. If a bias point is not given, one is calculated that is at the center of the parameter range of the input entity.</param>
    /// <param name="BiasPointTwo">Optional input object that is used help in determining the initial position of the occurrence. The occurrences are repositioned in an attempt to make the two bias points coincident. This provides some general control over the position of the occurrence when it isn't being controlled by another constraint. An example of when the bias points are useful is the case when the first constraint on a part is a mate constraint. In the case where the mate is between two planes, the parts can be positioned anywhere along the infinite plane that defines their mating contact. Using the bias points you can define the position of the two occurrences, relative to each other. If a bias point is not given, one is calculated that is at the center of the parameter range of the input entity.</param>
    /// <returns></returns>
    [PreserveSig]
    FlushConstraint AddFlushConstraint([In] [MarshalAs(UnmanagedType.IDispatch)] object EntityOne, [In] [MarshalAs(UnmanagedType.IDispatch)] object EntityTwo, [In] [MarshalAs(UnmanagedType.Struct)] object Offset, [In] [MarshalAs(UnmanagedType.Struct)] object? BiasPointOne = default, [In] [MarshalAs(UnmanagedType.Struct)] object? BiasPointTwo = default);
    /// <summary>
    /// Method that creates a new transitional constraint.
    /// </summary>
    /// <param name="FaceOne">Input that defines the initial face on the first occurrence that is used in repositioning the occurrences. Once the constraint is placed, it can move along any of the faces of the part.</param>
    /// <param name="FaceTwo">Input that defines the initial face on the second occurrence that is used in repositioning the occurrences. Once the constraint is placed, it can move along any of the faces of the part.</param>
    /// <param name="BiasPointOne">Optional input object that is used help in determining the initial position of the occurrence. The occurrences are repositioned in an attempt to make the two bias points coincident. This provides some general control over the position of the occurrence when it isn't being controlled by another constraint. An example of when the bias points are useful is the case when the first constraint on a part is a mate constraint. In the case where the mate is between two planes, the parts can be positioned anywhere along the infinite plane that defines their mating contact. Using the bias points you can define the position of the two occurrences, relative to each other. If a bias point is not given, one is calculated that is at the center of the parameter range of the input entity.</param>
    /// <param name="BiasPointTwo">Optional input object that is used help in determining the initial position of the occurrence. The occurrences are repositioned in an attempt to make the two bias points coincident. This provides some general control over the position of the occurrence when it isn't being controlled by another constraint.</param>
    /// <returns></returns>
    [PreserveSig]
    TransitionalConstraint AddTransitionalConstraint([In] [MarshalAs(UnmanagedType.Interface)] Face FaceOne, [In] [MarshalAs(UnmanagedType.Interface)] Face FaceTwo, [In] [MarshalAs(UnmanagedType.Struct)] object? BiasPointOne = default, [In] [MarshalAs(UnmanagedType.Struct)] object? BiasPointTwo = default);
    /// <summary>
    /// Method that creates a new rotation motion constraint.
    /// </summary>
    /// <param name="EntityOne">Input object that defines the first object and its rotation axis. The input object must be a planar , a revolved Point, a linear Edge, a WorkPlane, or a WorkAxis object. For planar objects the rotation axis is normal to the input face.</param>
    /// <param name="EntityTwo">Input object that defines the second object and its rotation axis. The input object must be a planar , a revolved Face, a linear Edge, a WorkPlane, or a WorkAxis object.</param>
    /// <param name="Ratio">Input Variant that defines the rotation ratio between the two input entities. This can be either a numeric value or a string. A parameter for this value is created and the supplied string or value is assigned to the parameter. The input value is unitless.</param>
    /// <param name="ForwardDirection">Input Boolean that defines the direction of rotation of the objects with respect to the axis direction. If the input value is True then both objects will rotate the same direction around their axes. If False, then they will rotate in opposite directions.</param>
    /// <param name="BiasPointOne">Optional input object that is used help in determining the initial position of the occurrence. The occurrences are repositioned in an attempt to make the two bias points coincident. This provides some general control over the position of the occurrence when it isn't being controlled by another constraint. An example of when the bias points are useful is the case when the first constraint on a part is a mate constraint. In the case where the mate is between two planes, the parts can be positioned anywhere along the infinite plane that defines their mating contact. Using the bias points you can define the position of the two occurrences, relative to each other. If a bias point is not given, one is calculated that is at the center of the parameter range of the input entity.</param>
    /// <param name="BiasPointTwo">Optional input object that is used help in determining the initial position of the occurrence. The occurrences are repositioned in an attempt to make the two bias points coincident. This provides some general control over the position of the occurrence when it isn't being controlled by another constraint. An example of when the bias points are useful is the case when the first constraint on a part is a mate constraint. In the case where the mate is between two planes, the parts can be positioned anywhere along the infinite plane that defines their mating contact. Using the bias points you can define the position of the two occurrences, relative to each other. If a bias point is not given, one is calculated that is at the center of the parameter range of the input entity.</param>
    /// <returns></returns>
    [PreserveSig]
    RotateRotateConstraint AddRotateRotateConstraint([In] [MarshalAs(UnmanagedType.IDispatch)] object EntityOne, [In] [MarshalAs(UnmanagedType.IDispatch)] object EntityTwo, [In] [MarshalAs(UnmanagedType.Struct)] object Ratio, [In] bool ForwardDirection, [In] [MarshalAs(UnmanagedType.Struct)] object? BiasPointOne = default, [In] [MarshalAs(UnmanagedType.Struct)] object? BiasPointTwo = default);
    /// <summary>
    /// Method that creates a new rotate-translate motion constraint.
    /// </summary>
    /// <param name="EntityOne">Input object that defines the first object and its rotation axis. The input object must be a planar , a revolved Face, a linear Edge, a WorkPlane, or a WorkAxis object. For planar objects the rotation axis is normal to the input face.</param>
    /// <param name="EntityTwo">Input object that defines the second object and its translation axis. The input object must be a planar , a revolved Face, a linear Edge, a WorkPlane, or a WorkAxis object. For planar objects the translation axis is normal to the input face.</param>
    /// <param name="Ratio">Input Variant that defines the distance of translation for every revolution of the rotated occurrence. This can be either a numeric value or a string. A parameter for this value is created and the supplied string or value is assigned to the parameter. If a value is input, the units are centimeters. If a string is input the units can be specified as part of the string or will default to the current length units of the document.</param>
    /// <param name="ForwardDirection">Input Boolean that defines the direction of translation with respect to the rotation direction relative to the axes directions. If the input value is True then when the rotation object is rotated in a positive direction about its axis, the translation object will move in the positive direction of its vector, If False, it will move in the negative direction.</param>
    /// <param name="BiasPointOne">Optional input object that is used help in determining the initial position of the occurrence. The occurrences are repositioned in an attempt to make the two bias points coincident. This provides some general control over the position of the occurrence when it isn't being controlled by another constraint. An example of when the bias points are useful is the case when the first constraint on a part is a mate constraint. In the case where the mate is between two planes, the parts can be positioned anywhere along the infinite plane that defines their mating contact. Using the bias points you can define the position of the two occurrences, relative to each other. If a bias point is not given, one is calculated that is at the center of the parameter range of the input entity.</param>
    /// <param name="BiasPointTwo">Optional input object that is used help in determining the initial position of the occurrence. The occurrences are repositioned in an attempt to make the two bias points coincident. This provides some general control over the position of the occurrence when it isn't being controlled by another constraint. An example of when the bias points are useful is the case when the first constraint on a part is a mate constraint. In the case where the mate is between two planes, the parts can be positioned anywhere along the infinite plane that defines their mating contact. Using the bias points you can define the position of the two occurrences, relative to each other. If a bias point is not given, one is calculated that is at the center of the parameter range of the input entity.</param>
    /// <returns></returns>
    [PreserveSig]
    RotateTranslateConstraint AddRotateTranslateConstraint([In] [MarshalAs(UnmanagedType.IDispatch)] object EntityOne, [In] [MarshalAs(UnmanagedType.IDispatch)] object EntityTwo, [In] [MarshalAs(UnmanagedType.Struct)] object Ratio, [In] bool ForwardDirection, [In] [MarshalAs(UnmanagedType.Struct)] object? BiasPointOne = default, [In] [MarshalAs(UnmanagedType.Struct)] object? BiasPointTwo = default);
    /// <summary>
    /// Missing documentation! Help us documenting it!
    /// </summary>
    /// <param name="EntityOne">EntityOne</param>
    /// <param name="EntityTwo">EntityTwo</param>
    /// <param name="ClientId">ClientId</param>
    [PreserveSig]
    CustomConstraint AddCustomConstraint([In] [MarshalAs(UnmanagedType.IDispatch)] object EntityOne, [In] [MarshalAs(UnmanagedType.IDispatch)] object EntityTwo, [In] [MarshalAs(UnmanagedType.BStr)] string ClientId);
    /// <summary>
    /// Missing documentation! Help us documenting it!
    /// </summary>
    /// <param name="EntityOne">EntityOne</param>
    /// <param name="EntityTwo">EntityTwo</param>
    /// <param name="SymmetryPlane">SymmetryPlane</param>
    /// <param name="EntityOneInferredType">EntityOneInferredType</param>
    /// <param name="EntityTwoInferredType">EntityTwoInferredType</param>
    [PreserveSig]
    AssemblySymmetryConstraint _AddSymmetryConstraint([In] [MarshalAs(UnmanagedType.IDispatch)] object EntityOne, [In] [MarshalAs(UnmanagedType.IDispatch)] object EntityTwo, [In] [MarshalAs(UnmanagedType.IDispatch)] object SymmetryPlane, [In] InferredTypeEnum? EntityOneInferredType = InferredTypeEnum.kNoInference, [In] InferredTypeEnum? EntityTwoInferredType = InferredTypeEnum.kNoInference);
    /// <summary>
    /// Creates a new Symmetry assembly constraint.
    /// </summary>
    /// <param name="EntityOne">Input entity that is to be symmetric.</param>
    /// <param name="EntityTwo">Input entity that is to be symmetric.</param>
    /// <param name="SymmetryPlane">Input planar entity that defines the symmetry plane. This can either be a planar face or a work plane.</param>
    /// <param name="EntityOneInferredType">Optional input constant that specifies how the geometry of entity one is to be interpreted. Depending on the geometry of the entity one, different options are possible.
    /// If entity one is a linear entity this can be either kNoInference or kInferredPoint, for kInferredPoint the mid-point of the linear entity is used for the constraint. If entity one is a circular/elliptical sketch entity, this can be either kInferredPiont or kInferredLine. If entity one is a cylindrical, elliptic-cylindrical, conical face this can be kNoInference or kInferredLine. If entity one is a toroidal face this can be either kInferredLine or kInferredPoint. If entity one is a spherical face this can be kInferredPoint. For a plane, only kNoInference is valid.</param>
    /// <param name="EntityTwoInferredType">Optional input enum that specifies how the geometry of entity two is to be interpreted. Depending on the geometry of the entity two, different options are possible. If entity two is a linear entity this can be either kNoInference or kInferredPoint, for kInferredPoint the mid-point of the linear entity is used for the constraint. If entity two is a circular/elliptical sketch entity, this can be either kInferredPiont or kInferredLine. If entity two is a cylindrical, elliptic-cylindrical, conical face this can be kNoInference or kInferredLine. If entity two is a toroidal face this can be either kInferredLine or kInferredPoint. If entity two is a spherical face this can be kInferredPoint. For a plane, only kNoInference is valid.</param>
    /// <param name="NormalsOpposed">This argument only applies when the two entities are planar (planar face or work plane) and defines if the normal of the planar entities are oriented so they are opposed or aligned.  If the input entities are not planar, this argument is ignored.  If they are planar and this argument is not specified they will defined to be opposed.</param>
    /// <returns></returns>
    [PreserveSig]
    AssemblySymmetryConstraint AddSymmetryConstraint([In] [MarshalAs(UnmanagedType.IDispatch)] object EntityOne, [In] [MarshalAs(UnmanagedType.IDispatch)] object EntityTwo, [In] [MarshalAs(UnmanagedType.IDispatch)] object SymmetryPlane, [In] InferredTypeEnum? EntityOneInferredType = InferredTypeEnum.kNoInference, [In] InferredTypeEnum? EntityTwoInferredType = InferredTypeEnum.kNoInference, [In] bool? NormalsOpposed = true);
    /// <summary>
    /// Creates a new Mate assembly constraint.
    /// </summary>
    /// <param name="EntityOne">Input object that defines the first object.</param>
    /// <param name="EntityTwo">Input object that defines the second object.</param>
    /// <param name="Offset">Input Variant that defines the offset between the two input entities. This can be either a numeric value or a string. A parameter for this value is created and the supplied string or value is assigned to the parameter. If a value is input, the units are centimeters. If a string is input the units can be specified as part of the string or will default to the current length units of the document.</param>
    /// <param name="EntityOneInferredType">Optional input constant that specifies how the geometry of entity one is to be interpreted. Depending on the geometry of the entity one, different options are possible. If entity one is a cylinder this can be either kNoInference or kInferredLine. For kNoInference to be valid for a cylinder, entity two must also be a cylinder and they must be the same radius. If entity one is a sphere this can be either kNoInference or kInferredPoint. For kNoInference to be valid for a sphere, entity two must also be a sphere and they must be the same radius. If entity one is a cone this can be either kNoInference or kInferredLine. For kNoInference to be valid for a cone, entity two must also be a cone and they must have the same taper angle. If entity one is a torus this can be either kInferredLine or kInferredPoint. For a plane, only kNoInference is valid.</param>
    /// <param name="EntityTwoInferredType">Input enum that specifies how the geometry of entity two is to be interpreted. Depending on the geometry of the entity two, different options are possible. If entity two is a cylinder this can be either kNoInference or kInferredLine. For kNoInference to be valid for a cylinder, entity one must also be a cylinder and they must be the same radius. If entity two is a sphere this can be either kNoInference or kInferredPoint. For kNoInference to be valid for a sphere, entity one must also be a sphere and they must be the same radius. If entity two is a cone this can be either kNoInference or kInferredLine. For kNoInference to be valid for a cone, entity one must also be a cone and they must have the same taper angle. If entity two is a torus this can be either kInferredLine or kInferredPoint. For a plane, only kNoInference is valid.</param>
    /// <param name="SolutionType">Optional input MateConstraintSolutionTypeEnum that specifies the solution type for the mate constraint. If not provided this defaults to kOpposedSolutionType.</param>
    /// <param name="BiasPointOne">Optional input object that is used help in determining the initial position of the occurrence. The occurrences are repositioned in an attempt to make the two bias points coincident. This provides some general control over the position of the occurrence when it isn't being controlled by another constraint. An example of when the bias points are useful is the case when the first constraint on a part is a mate constraint. In the case where the mate is between two planes, the parts can be positioned anywhere along the infinite plane that defines their mating contact. Using the bias points you can define the position of the two occurrences, relative to each other. If a bias point is not given, one is calculated that is at the center of the parameter range of the input entity.</param>
    /// <param name="BiasPointTwo">Optional input object that is used help in determining the initial position of the occurrence. The occurrences are repositioned in an attempt to make the two bias points coincident. This provides some general control over the position of the occurrence when it isn't being controlled by another constraint. An example of when the bias points are useful is the case when the first constraint on a part is a mate constraint. In the case where the mate is between two planes, the parts can be positioned anywhere along the infinite plane that defines their mating contact. Using the bias points you can define the position of the two occurrences, relative to each other. If a bias point is not given, one is calculated that is at the center of the parameter range of the input entity.</param>
    /// <returns></returns>
    [PreserveSig]
    MateConstraint AddMateConstraint2([In] [MarshalAs(UnmanagedType.IDispatch)] object EntityOne, [In] [MarshalAs(UnmanagedType.IDispatch)] object EntityTwo, [In] [MarshalAs(UnmanagedType.Struct)] object Offset, [In] InferredTypeEnum? EntityOneInferredType = InferredTypeEnum.kNoInference, [In] InferredTypeEnum? EntityTwoInferredType = InferredTypeEnum.kNoInference, [In] MateConstraintSolutionTypeEnum? SolutionType = MateConstraintSolutionTypeEnum.kOpposedSolutionType, [In] [MarshalAs(UnmanagedType.Struct)] object? BiasPointOne = default, [In] [MarshalAs(UnmanagedType.Struct)] object? BiasPointTwo = default);
    /// <summary>
    /// Creates a new Insert assembly constraint.
    /// </summary>
    /// <param name="EntityOne">Object that defines the first object. This object is a circular edge.</param>
    /// <param name="EntityTwo">Object that defines the second object. This object is a circular edge.</param>
    /// <param name="AxesOpposed">Input Boolean that specifies whether the direction of the axes of the input entities are in the same direction or opposed. A value of True indicates they are opposed.</param>
    /// <param name="Distance">Input Variant that defines the offset between the two input entities. This can be either a numeric value or a string. A parameter for this value is created and the supplied string or value is assigned to the parameter. If a value is input, the units are centimeters. If a string is input the units can be specified as part of the string or will default to the current length units of the document.</param>
    /// <param name="LockRotation">Optional input Boolean value that specifies whether to lock the rotation or not.</param>
    /// <param name="BiasPointOne">Optional input object that is used help in determining the initial position of the occurrence. The occurrences are repositioned in an attempt to make the two bias points coincident. This provides some general control over the position of the occurrence when it isn't being controlled by another constraint. An example of when the bias points are useful is the case when the first constraint on a part is a mate constraint. In the case where the mate is between two planes, the parts can be positioned anywhere along the infinite plane that defines their mating contact. Using the bias points you can define the position of the two occurrences, relative to each other. If a bias point is not given, one is calculated that is at the center of the parameter range of the input entity.</param>
    /// <param name="BiasPointTwo">Optional input object that is used help in determining the initial position of the occurrence. The occurrences are repositioned in an attempt to make the two bias points coincident. This provides some general control over the position of the occurrence when it isn't being controlled by another constraint. An example of when the bias points are useful is the case when the first constraint on a part is a mate constraint. In the case where the mate is between two planes, the parts can be positioned anywhere along the infinite plane that defines their mating contact. Using the bias points you can define the position of the two occurrences, relative to each other. If a bias point is not given, one is calculated that is at the center of the parameter range of the input entity.</param>
    /// <returns></returns>
    [PreserveSig]
    InsertConstraint AddInsertConstraint2([In] [MarshalAs(UnmanagedType.IDispatch)] object EntityOne, [In] [MarshalAs(UnmanagedType.IDispatch)] object EntityTwo, [In] bool AxesOpposed, [In] [MarshalAs(UnmanagedType.Struct)] object Distance, [In] [MarshalAs(UnmanagedType.Struct)] object? LockRotation = default, [In] [MarshalAs(UnmanagedType.Struct)] object? BiasPointOne = default, [In] [MarshalAs(UnmanagedType.Struct)] object? BiasPointTwo = default);
}
